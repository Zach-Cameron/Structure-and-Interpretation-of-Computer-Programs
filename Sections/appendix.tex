\newpage
\appendix
\section*{Appendix}
%%%%%%%%%%%%%%%%%%%

\section{Notes on LISP}
\label{sec:lisp}

\subsection{McCarthy 1960}

\href{http://jmc.stanford.edu/articles/recursive.html}{\textit{Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I}}


LISP:
\begin{itemize}
    \item \textbf{LIS}t \textbf{P}rocessor
    \item Developed for the IBM 704 computer by the Artificial Intelligence group at M.I.T.
    \item Designed to facilitate experiments with a proposed system called the \textit{Advice Tracker}:
    \begin{itemize}
        \item a machine that could be instructed to handle declarative as well as imperative sentences and could exhibit ``common sense'' in carrying out its instructions.
        \item originally proposed in November 1958.
    \end{itemize}
    \item main requirement was a programming system for manipulating expressions representing formalized declarative and imperative sentences so that the Advice Taker system could make deductions.
\end{itemize}

\begin{defn}[\idx{conditional statement}]
    A \textbi{conditional expression} has the form \[(p_{1} \rightarrow e_{1}, p_{2} \rightarrow e_{2}, \cdots, p_{n} \rightarrow e_{n})\] where each $p_{i}$ is a propositional expression and each $e_{1}$ is an expression of any kind.

    It is read ``if $p_{1}$ then $e_{1}$, else if $p_{2}$ then $e_{2}$, else ... else if $p_{n}$ then $e_{n}$.''

    Determining the value, starting from $i=1$:
    \begin{itemize}
        \item If $p_{i}$ is undefined or if $i=n$ and $p_{n}$ is false, then the value is \textit{undefined}.
        \item If $p_{i}$ is true, then the value is $e_{i}$.
        \item If $p_{i}$ is false, check $p_{i+1}$.
    \end{itemize}

    \begin{exmp}
        \begin{itemize}
            \item $(1<2 \rightarrow 4,\ 1>2 \rightarrow 3) = 4$
            \item $(2<1 \rightarrow 4,\ 2>1 \rightarrow 3,\ 2>1 \rightarrow 2) = 3$
            \item $(2<1 \rightarrow 4,\ T \rightarrow 3) = 3$
            \item $(2<1 \rightarrow \frac{0}{0},\ T \rightarrow 3) = 3$
            \item $(2<1 \rightarrow 3,\ 4<1 \rightarrow 4)$ is undefined.
            \item $(2<1 \rightarrow 3,\ 4<1 \rightarrow 4)$ is undefined.
        \end{itemize}
    \end{exmp}

    \begin{exmp}
        \begin{itemize}
            \item $\left|x\right| = (x<0 \rightarrow -x,\ T \rightarrow x)$
            \item $\delta_{ij} = (i=j \rightarrow 1,\ T \rightarrow 0)$
            \item $\text{sgn}(x) = (x<0 \rightarrow -1,\ x=0 \rightarrow 0,\ T \rightarrow 1)$
        \end{itemize}
    \end{exmp}
    
    \begin{exmp}[recursive functions]
        \begin{itemize}
            \item $n! = (n=0 \rightarrow 1,\ T \rightarrow n \cdot (n+1)!)$
            \item $\text{gcd}(m,n) = (m>n \rightarrow \text{gcd}(n,m),\ \text{rem}(n,m) = 0 \rightarrow m,\ T \rightarrow \text{gcd}(\text{rem}(n,m),m))$
            \item $\text{sqrt}(a, x, \epsilon) = (\left|x^{2}-a\right|<\epsilon \rightarrow x,\ T \rightarrow \text{sqrt}(a, \frac{1}{2}(x+\frac{a}{x}), \epsilon))$
        \end{itemize}
    \end{exmp}
    
    \begin{exmp}[propositions]
        \begin{itemize}
            \item $p \land q = (p \rightarrow q,\ T \rightarrow F)$
            \item $p \lor q = (p \rightarrow T,\ T \rightarrow q)$
            \item $\neg p = (p \rightarrow F,\ T \rightarrow T)$
            \item $p \supset q = (p \rightarrow q,\ T \rightarrow T)$
        \end{itemize}
    \end{exmp}
\end{defn}



\begin{defn}[\idx{function}]
    A \textbi{function} has the form \[\lambda((x_{1},\ldots,x_{n}),\ \mathcal{E})\] where $(x_{1},\ldots,x_{n})$ is a list of $n$ variables and $\mathcal{E}$ is a form of those variables.
    \begin{exmp}
        $\lambda((x,y),\ y^{2}+x)(3,4) = 19$
    \end{exmp}

    \begin{rmrk}
        Variables occurring in the list of variables are dummy or bound variables. We may change the names of the bound variables in a function expression without changing the value of the expression, provided that we make the same change for each occurrence of the variable and do not make two variables the same that previously were different.
        \begin{exmp}
            $\lambda((x,y),\ y^{2}+x) = \lambda((u,v),\ v^{2}+u)$
        \end{exmp}
    \end{rmrk}
\end{defn}

\begin{defn}[\idx{$label(a,\mathcal{E})$}]
    $label(a,\mathcal{E})$ denotes the expression $\mathcal{E}$ provided that occurrences of $a$ within $\mathcal{E}$ are to be interpreted as referring to the expression as a whole.
    \begin{exmp}
        $\lambda$-notation is inadequate for naming functions defined recursively. For example, we can convert the definition \[\text{sqrt}(a,x,\epsilon) = (|x^{2}-a|<\epsilon \rightarrow x,\ T \rightarrow \text{sqrt}(a, \frac{1}{2}(x+\frac{a}{x}), \epsilon))\] into \[\text{sqrt} = \lambda((a,x,\epsilon),\ (|x^{2}-a|<\epsilon \rightarrow x,\ T \rightarrow \text{sqrt}(a, \frac{1}{2}(x+\frac{a}{x}), \epsilon)))\] but the right-hand side cannot serve as an expression for the function because there would be nothing to indicate that the reference to sqrt within the expression stood for the expression as a whole.

        The $label$ notation makes explicit what symbol in $\mathcal{E}$ should refer to the statement itself. Thus we can write \[label(\text{sqrt},\ \lambda((a,x,\epsilon),\ (|x^{2}-a|<\epsilon \rightarrow x,\ T \rightarrow \text{sqrt}(a, \frac{1}{2}(x+\frac{a}{x}), \epsilon))))\] as a name for our sqrt function.
    \end{exmp}
    
\end{defn}



\subsection{LISP 1.5 Programmer's Manual}

\href{https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf}{\textit{LISP 1.5 Programmer's Manual}}

