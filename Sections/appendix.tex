\newpage
\appendix
\section*{Appendix}
%%%%%%%%%%%%%%%%%%%

\section{Notes on LISP}
\label{sec:lisp}

\subsection{McCarthy 1960}

\href{http://jmc.stanford.edu/articles/recursive.html}{\textit{Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I}}


LISP:
\begin{itemize}
    \item \textbf{LIS}t \textbf{P}rocessor
    \item Developed for the IBM 704 computer by the Artificial Intelligence group at M.I.T.
    \item Designed to facilitate experiments with a proposed system called the \textit{Advice Tracker}:
    \begin{itemize}
        \item a machine that could be instructed to handle declarative as well as imperative sentences and could exhibit ``common sense'' in carrying out its instructions.
        \item originally proposed in November 1958.
    \end{itemize}
    \item main requirement was a programming system for manipulating expressions representing formalized declarative and imperative sentences so that the Advice Taker system could make deductions.
\end{itemize}

\begin{defn}[\idx{conditional statement}]
    A \textbi{conditional expression} has the form \[(p_{1} \rightarrow e_{1}, p_{2} \rightarrow e_{2}, \cdots, p_{n} \rightarrow e_{n})\] where each $p_{i}$ is a propositional expression and each $e_{1}$ is an expression of any kind.

    It is read ``if $p_{1}$ then $e_{1}$, else if $p_{2}$ then $e_{2}$, else ... else if $p_{n}$ then $e_{n}$.''

    Determining the value, starting from $i=1$:
    \begin{itemize}
        \item If $p_{i}$ is undefined or if $i=n$ and $p_{n}$ is false, then the value is \textit{undefined}.
        \item If $p_{i}$ is true, then the value is $e_{i}$.
        \item If $p_{i}$ is false, check $p_{i+1}$.
    \end{itemize}

    \begin{exmp}
        \begin{itemize}
            \item $(1<2 \rightarrow 4,\ 1>2 \rightarrow 3) = 4$
            \item $(2<1 \rightarrow 4,\ 2>1 \rightarrow 3,\ 2>1 \rightarrow 2) = 3$
            \item $(2<1 \rightarrow 4,\ T \rightarrow 3) = 3$
            \item $(2<1 \rightarrow \frac{0}{0},\ T \rightarrow 3) = 3$
            \item $(2<1 \rightarrow 3,\ 4<1 \rightarrow 4)$ is undefined.
            \item $(2<1 \rightarrow 3,\ 4<1 \rightarrow 4)$ is undefined.
        \end{itemize}
    \end{exmp}

    \begin{exmp}
        \begin{itemize}
            \item $\left|x\right| = (x<0 \rightarrow -x,\ T \rightarrow x)$
            \item $\delta_{ij} = (i=j \rightarrow 1,\ T \rightarrow 0)$
            \item $\text{sgn}(x) = (x<0 \rightarrow -1,\ x=0 \rightarrow 0,\ T \rightarrow 1)$
        \end{itemize}
    \end{exmp}
    
    \begin{exmp}[recursive functions]
        \begin{itemize}
            \item $n! = (n=0 \rightarrow 1,\ T \rightarrow n \cdot (n+1)!)$
            \item $\text{gcd}(m,n) = (m>n \rightarrow \text{gcd}(n,m),\ \text{rem}(n,m) = 0 \rightarrow m,\ T \rightarrow \text{gcd}(\text{rem}(n,m),m))$
            \item $\text{sqrt}(a, x, \epsilon) = (\left|x^{2}-a\right|<\epsilon \rightarrow x,\ T \rightarrow \text{sqrt}(a, \frac{1}{2}(x+\frac{a}{x}), \epsilon))$
        \end{itemize}
    \end{exmp}
    
    \begin{exmp}[propositions]
        \begin{itemize}
            \item $p \land q = (p \rightarrow q,\ T \rightarrow F)$
            \item $p \lor q = (p \rightarrow T,\ T \rightarrow q)$
            \item $\neg p = (p \rightarrow F,\ T \rightarrow T)$
            \item $p \supset q = (p \rightarrow q,\ T \rightarrow T)$
        \end{itemize}
    \end{exmp}
\end{defn}



\begin{defn}[\idx{function}]
    A \textbi{function} has the form \[\lambda((x_{1},\ldots,x_{n}),\ \mathcal{E})\] where $(x_{1},\ldots,x_{n})$ is a list of $n$ variables and $\mathcal{E}$ is a form of those variables.
    \begin{exmp}
        $\lambda((x,y),\ y^{2}+x)(3,4) = 19$
    \end{exmp}

    \begin{rmrk}
        Variables occurring in the list of variables are dummy or bound variables. We may change the names of the bound variables in a function expression without changing the value of the expression, provided that we make the same change for each occurrence of the variable and do not make two variables the same that previously were different.
        \begin{exmp}
            $\lambda((x,y),\ y^{2}+x) = \lambda((u,v),\ v^{2}+u)$
        \end{exmp}
    \end{rmrk}
\end{defn}

\begin{defn}[\idx{$label(a,\mathcal{E})$}]
    $label(a,\mathcal{E})$ denotes the expression $\mathcal{E}$ provided that occurrences of $a$ within $\mathcal{E}$ are to be interpreted as referring to the expression as a whole.
    \begin{exmp}
        $\lambda$-notation is inadequate for naming functions defined recursively. For example, we can convert the definition \[\text{sqrt}(a,x,\epsilon) = (|x^{2}-a|<\epsilon \rightarrow x,\ T \rightarrow \text{sqrt}(a, \frac{1}{2}(x+\frac{a}{x}), \epsilon))\] into \[\text{sqrt} = \lambda((a,x,\epsilon),\ (|x^{2}-a|<\epsilon \rightarrow x,\ T \rightarrow \text{sqrt}(a, \frac{1}{2}(x+\frac{a}{x}), \epsilon)))\] but the right-hand side cannot serve as an expression for the function because there would be nothing to indicate that the reference to sqrt within the expression stood for the expression as a whole.

        The $label$ notation makes explicit what symbol in $\mathcal{E}$ should refer to the statement itself. Thus we can write \[label(\text{sqrt},\ \lambda((a,x,\epsilon),\ (|x^{2}-a|<\epsilon \rightarrow x,\ T \rightarrow \text{sqrt}(a, \frac{1}{2}(x+\frac{a}{x}), \epsilon))))\] as a name for our sqrt function.
    \end{exmp}
\end{defn}

\begin{defn}[\idx{atomic symbol}]
    A string starting with one of $\{A,B,\ldots,Z\}$ and continuing with zero or more of $\{A,B,\ldots,Z,0,1,\ldots,9\}$.
\end{defn}

\begin{defn}[\idx{S-expression}]
    \begin{enumerate}
        \item Atomic symbols are S-expressions.
        \item If $e_{1}$ and $e_{2}$ are S-expressions, so is $(e_{1} \cdot e_{2})$.
    \end{enumerate}

    \begin{note}
        `S' stands for `symbolic'.
    \end{note}
\end{defn}



\begin{nota}
    The list \[(x_{1}, x_{2}, \ldots, x_{n})\] is represented by the S-expression \[(x_{1} \cdot (x_{2} \cdot (\ldots \cdot (x_{n} \cdot NIL)\ldots)))\]

    \begin{exmp}
        $((A,B),C,D\cdot E) = ((A \cdot (B \cdot NIL)) \cdot (C \cdot ((D \cdot E) \cdot NIL)))$
    \end{exmp}
\end{nota}

\begin{defn}[\idx{M-expression}]
    An expression representing a function of S-expressions. 
    \begin{nota}
        In order to clearly distinguish the expressions representing functions from S-expressions, we shall use sequences of lower-case letters for function names and variables ranging over the set of S-expressions. We also use brackets and semicolons, instead of parentheses and commas, for denoting the application of functions to their arguments.
    \end{nota}
    \begin{exmp}
        \begin{itemize}
            \item $car[x]$
            \item $car[cons[(A \cdot B);x]]$
        \end{itemize}
    \end{exmp}
    \begin{note}
        `M' stands for `meta'.
    \end{note}    
\end{defn}

\begin{defn}[\idx{$atom[x]$}]
    $atom[x]$ has the value of True or False according to whether $x$ is an
    atomic symbol.
    \begin{exmp}
        \begin{itemize}
            \item $atom[X] = T$
            \item $atom[(X \cdot A)] = F$
        \end{itemize}
    \end{exmp}
\end{defn}

\begin{defn}[\idx{$eq[x;y]$}]
    $eq[x;y]$ is defined if and only if both $x$ and $y$ are atomic. $eq[x;y] = T$ if $x$ and $y$ are the same symbol, and $eq[x;y] = F$ otherwise.
    \begin{exmp}
        \begin{itemize}
            \item $eq[X;X] = T$
            \item $eq[X;A] = F$
            \item $eq[X;(X \cdot A)] $ is undefined.
        \end{itemize}
    \end{exmp}
\end{defn}

\begin{defn}[\idx{$car[x]$}]
    $car[x]$ is defined if and only if $x$ is not atomic. $car[(e_{1} \cdot e_{2})] = e_{1}$.
    \begin{exmp}
        \begin{itemize}
            \item $car[(X \cdot A)] = X$
            \item $car[((X \cdot A) \cdot Y)] = (X \cdot A)$
            \item $car[X]$ is undefined.
        \end{itemize}
    \end{exmp}
\end{defn}

\begin{defn}[\idx{$cdr[x]$}]
    $cdr[x]$ is also defined when $x$ is not atomic. $cdr[(e_{1} \cdot e_{2})] = e_{2}$.
    \begin{exmp}
        \begin{itemize}
            \item $cdr[(X \cdot A)] = A$
            \item $cdr[((X \cdot A) \cdot Y)] = Y$
            \item $cdr[X]$ is undefined.
        \end{itemize}
    \end{exmp}
\end{defn}

\begin{defn}[\idx{$cons[x;y]$}]
    $cons[x;y]$ is defined for any $x$ and $y$. $cons[e_{1}; e_{2}] = (e_{1} \cdot e_{2})$.
    \begin{exmp}
        \begin{itemize}
            \item $cons[X;A] = (X \cdot A)$
            \item $cons[(X \cdot A); Y] = ((X \cdot A) \cdot Y)$
        \end{itemize}
    \end{exmp}
\end{defn}

\begin{exmp}
    \begin{itemize}
        \item $car[cons[x;y]] = x$
        \item $cdr[cons[x;y]] = y$
        \item $cons[car[x];cdr[x]] = x$ for non-atomic $x$
    \end{itemize}
\end{exmp}

\begin{defn}[\idx{\texttt{ff[x]}}]
\begin{verbatim}ff[x] = [
    atom[x] -> x;
    T -> ff[car[x]]
]\end{verbatim}
    Returns the first atomic symbol of $x$.
\begin{exmp}
\begin{verbatim}ff[((A.B).C)] ->
    ff[(A.B)] ->
    ff[A] ->
    atom[A] ->
    A\end{verbatim}
\end{exmp}
\end{defn}
 
\begin{defn}[\idx{\texttt{subst[x;y;z]}}]
\begin{verbatim}subst[x;y;z] = [
    atom[z] -> [
        eq[z;y] -> x;
        T -> z
    ];
    T -> cons[
        subst[x;y;car[z]];
        subst[x;y;cdr[z]]
    ]
]\end{verbatim}
    Returns a copy of the S-expression $z$ such that every occurrence of $y$ in $z$ has been replaced with $x$.
    \begin{exmp}
        $subst[(X \cdot A);\ B;\ ((A \cdot B) \cdot C)] = ((A \cdot (X \cdot A)) \cdot C)$
    \end{exmp}
\end{defn}

\begin{defn}[\idx{\texttt{equal[x;y]}}]
\begin{verbatim}equal[x;y] = [
    [atom[x] AND atom[y] AND eq[x;y]] OR
    [-atom[x] AND -atom[y] AND equal[car[x];car[y]] AND equal[cdr[x];cdr[y]]]
]\end{verbatim}
    Returns True or False according to whether $x$ and $y$ are equivalent.
\end{defn}

\begin{defn}[\idx{\texttt{null[x]}}]
\begin{verbatim}null[x] = [
    atom[x] AND eq[x;NIL]
]\end{verbatim}
    Returns True or False according to whether $x$ is the atomic symbol $NIL$. 
\end{defn}

\begin{nota}
    When navigating through nested S-expressions, an expression such as \[car[cdr[cdr[car[cdr[x]]]]]\] could occur. As a shorthand, this example expression can be written as \[caddadr[x]\]
\end{nota}

\begin{nota}
   Another useful abbreviation is to write \[list[e_{1};e_{2};\ldots;e_{n}]\] for \[cons[e_{1};cons[e_{2};cons[\ldots;cons[e_{n};NIL]]]]\]
\end{nota}

\begin{defn}[\idx{\texttt{append[x;y]}}]
\begin{verbatim}append[x;y] = [
    null[x] -> y;
    T -> cons[car[x];append[cdr[x];y]]
]\end{verbatim}
    Given lists $x$ and $y$, return a copy of $x$ such that the $NIL$ that marks the end of the list $x$ is substituted with the list $y$, which effectively appends $y$ onto $x$.
\end{defn}

\begin{defn}[\idx{\texttt{among[x;y]}}]
\begin{verbatim}among[x;y] = [
    -null[y] AND [
        equal[x;car[y]] OR among[x;cdr[y]]
    ]
]\end{verbatim}
    Returns True or False according to whether $x$ is among the members of the list $y$.
\end{defn}

\begin{defn}[\idx{\texttt{pair[x;y]}}]
\begin{verbatim}pair[x;y] = [
    null[x] AND null[y] -> NIL;
    -atom[x] AND -atom[y] -> cons[
        list[car[x];car[y]];
        pair[cdr[x];cdr[y]]
    ]
]\end{verbatim}
    Returns a list whose $i$th member is a list $(X_{i}, Y_{i})$ where $X_{i}$ is the $i$th member of $x$ and $Y_{i}$ is the $i$th member of $y$.
    \begin{exmp}
        \begin{itemize}
            \item $pair[(A,B,C);(X,(Y,Z),U)] = ((A,X),(B,(Y,Z)),(C,U))$
            \item $pair[(A,B);(C,D,E)]$ is undefined. Eventually $x=NIL$ and $y=(E \cdot NIL)$. Since $y \neq NIL$ and $x$ is atomic, the conditions of $pair[(A,B);(C,D,E)]$ are all false.
        \end{itemize}
    \end{exmp}
\end{defn}

\begin{defn}[\idx{\texttt{assoc[x;y]}}]
\begin{verbatim}assoc[x;y] = [
    eq[caar[y];x] -> cadar[y];
    T -> assoc[x;cdr[y]]
]\end{verbatim}
    Given that $y$ is a list of key-value pairs $(k_{i},v_{i})$, if $x$ matches one of the keys $k_{i}$ then return the corresponding value $v_{i}$.
    \begin{exmp}
        $assoc[X;((W,(A,B)),(X,(C,D)),(Y,(E,F)))] = (C,D)$
    \end{exmp}
\end{defn}

\begin{defn}[\idx{\texttt{sublis[x;y]}},\ \idx{\texttt{sub2[x;z]}}]
\begin{verbatim}sublis[x;y] = [
    atom[y] -> sub2[x;y];
    T -> cons[
        sublis[x;car[y]];
        sublis[x;cdr[y]]
    ]
]\end{verbatim}
\begin{verbatim}sub2[x;z] = [
    null[x] -> z;
    eq[caar[x];z] -> cadar[x];
    T -> sub2[cdr[x];z]
]\end{verbatim}
    Given $x$ is a list of key-value pairs $(k_{i},v_{i})$ where each $k_{i}$ is atomic, $sublis[x;y]$ returns a copy of $y$ such that for every atomic symbol $z$ in $y$, if $z$ is a key $k_{i}$ of $x$ then substitute $z$ for the corresponding value $v_{i}$.
\end{defn}

\subsection{LISP 1.5 Programmer's Manual}

\href{https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf}{\textit{LISP 1.5 Programmer's Manual}}

