\newpage
\appendix

\section*{Appendix}

\section{McCarthy 1960}
\label{sec:lisp}

\href{http://jmc.stanford.edu/articles/recursive.html}{\textit{Recursive Functions of Symbolic Expressions and Their Computation by Machine}}

\subsection{Introduction}

LISP: 
\begin{itemize}
    \item "\textbf{LIS}t \textbf{P}rocessor"
    \item Developed for the IBM 704 computer by the Artificial Intelligence group at M.I.T. 
    \item Designed to facilitate experiments with a proposed system called the \textit{Advice Tracker}:
    \begin{itemize}
        \item A programming system for manipulating expressions representing formalized declarative and imperative sentences so that the Advice Tracker system could make deductions.
        \item Originally proposed in November 1958.
    \end{itemize}
    \item Came to be based on a scheme for representing the partial recursive functions of a certain class of symbolic expressions, independent of any electronic computer.
\end{itemize}

In this article:
\begin{enumerate}
    \item Describe a formalism for defining functions recursively.
    \item Describe S-expressions and S-functions, give examples, and describe the universal S-function \texttt{apply} which plays the theoretical role of a universal Turing machine and the practical role of an interpreter.
    \item Describe the representation of S-expressions in the memory of the IBM 704 by list structures ... and the representation of S-functions by program.
    \item Mention the main features of the LISP programming system for the IBM 704.
    \item Another way of describing computations with symbolic expressions.
    \item Give a recursive function interpretation of flow charts. 
\end{enumerate}

\subsection{Functions and Function Definitions}

\begin{defn}[\idx{partial function}]
    A function that is defined only on part of its domain.
\end{defn}

\begin{defn}[\idx{propositional expression}]
    A \textbi{propositional expression} is an expression whose possible values are $T$ (for truth) and $F$ (for falsity).
\end{defn}

\begin{defn}[\idx{predicate}]
    A function whose range consists of the truth values $T$ and $F$.
\end{defn}

\begin{defn}[\idx{conditional expression}]
    A device for expressing the dependence of quantities on propositional quantities, denoted: \[(p_{1} \rightarrow e_{1}, \cdots, p_{n} \rightarrow e_{n})\] where the $p$'s are propositional expressions and the $e$'s are expression of any kind, read ``If $p_{1}$ then $e_{1}$, otherwise if $p_{2}$ then $e_{2}$, ... otherwise if $p_{n}$ then $e_{n}$'' or ``$p_{1}$ yields $e_{1}$, ..., $p_{n}$ yields $e_{n}$.''

    \textbf{How to determine the value of an arbitrary conditional statement $(p_{1} \rightarrow e_{1}, \cdots, p_{n} \rightarrow e_{n})$}:
    \begin{itemize}
        \item Let $i=1$.
        \item If the value of $p_{i}$ is undefined, then the value of the conditional expression is undefined.
        \item If the value of $p_{i}$ is $T$, then the value of the conditional expression is the value of the expression $e_{i}$.
        \item If the value of $p_{i}$ is $F$, then increment $i$ and evaluate $p_{i}$.
    \end{itemize}
\end{defn}

\begin{exmp}
    \hfill
    \begin{itemize}
        \item $(1 < 2 \rightarrow 4,\ 1 > 2 \rightarrow 3) = 4$
        
        Starting from the left with the statement $1 < 2 \rightarrow 4$, the propositional expression $1 < 2$ is true, therefore the value of the conditional expression is $4$.

        \item $(2 < 1 \rightarrow 4,\ 2 > 1 \rightarrow 3,\ 2 > 1 \rightarrow 2) = 3$
        
        Starting from the left with the statement $2 < 1 \rightarrow 4$, the propositional expression $2 < 1$ is false. Moving on to the next statement $2 > 1 \rightarrow 3$, the propositional expression $2 > 1$ is true, therefore the value of the conditional expression is $3$.

        \item $(2 < 1 \rightarrow 4,\ T \rightarrow 3) = 3$
        
        The propositional expression $2 < 1$ is false, so move on. The propositional expression $T$ is true, therefore the value of the conditional expression is $3$. 

        \item $(2 < 1 \rightarrow \frac{0}{0},\ T \rightarrow 3) = 3$
        
        The propositional expression $2 < 1$ is false, so move on. The propositional expression $T$ is true, therefore the value of the conditional expression is $3$.

        \item $(2 < 1 \rightarrow 3,\ T \rightarrow \frac{0}{0})$ is undefined.
        
        The propositional expression $2 < 1$ is false, so move on. The propositional expression $T$ is true, therefore the value of the conditional expression is the value of the expression $\frac{0}{0}$ which is undefined.

        \item $(2 < 1 \rightarrow 3,\ 4 < 1 \rightarrow 4)$ is undefined.
        
        The propositional expression $2 < 1$ is false, so move on. The propositional expression $4 < 1$ is false, so move on. There's nothing else to move on to, so the value of the conditional expression is undefined.
    \end{itemize}
\end{exmp}

\begin{exmp}
    Applications:
    \begin{itemize}
        \item $\left|x\right| = (x < 0 \rightarrow -x,\ T \rightarrow x)$
        \item $\delta_{ij} = (i=j \rightarrow 1, T \rightarrow 0)$
        \item $sgn(x) = (x < 0 \rightarrow -1,\ x = 0 \rightarrow 0,\ T \rightarrow 1)$
    \end{itemize}
\end{exmp}

\begin{exmp}
    Recursive applications:
    \begin{itemize}
        \item $n! = (n = 0 \rightarrow 1,\ T \rightarrow n \cdot (n-1)!)$
        \item $\gcd(m,n) = (m > n \rightarrow \gcd(n,m),\ rem(n,m) = 0 \rightarrow m,\ T \rightarrow \gcd(rem(n,m),m))$
        \item $\text{sqrt}(a, x, \epsilon) = (\left|x^{2} - a\right| < \epsilon \rightarrow x,\ T \rightarrow \text{sqrt}(a, \frac{1}{2}(x+\frac{a}{x}), \epsilon))$ 
    \end{itemize}
\end{exmp}

\begin{exmp}
    Propositional connectives defined by conditional expressions:
    \begin{itemize}
        \item $p \land q = (p \rightarrow q,\ T \rightarrow F)$
        \item $p \lor q = (p \rightarrow T,\ T \rightarrow q)$
        \item $\neg p = (p \rightarrow F,\ T \rightarrow T)$
        \item $p \supset q = (p \rightarrow q,\ T \rightarrow T)$
    \end{itemize}
\end{exmp}

\begin{defn}[\idx{form}]
    The expression $y^{2}+x$ is an example of a form.
\end{defn}

\begin{defn}[\idx{function}]
    A function substitutes arguments into a form to evaluate a result. It's necessarily to know which arguments map to which variables of the form. Something like $y^{2}+x(3,4)$ is not a function because it's not clear how $(3,4)$ should map to $x$ and $y$. If we make explicit the positions of the variables in the ordered tuple of arguments, then the mapping is clear. So, $\lambda((x,y),\ y^{2}+x)$ is a function, where e.g. $\lambda((x,y),\ y^{2}+x)(3,4)$ evaluates to $4^{2}+3 = 19$.

    A function of $n$ arguments is denoted \[\lambda((x_{1},\ldots,x_{n}),\ \mathcal{E})\] where $\mathcal{E}$ is a form of $n$ variables $x_{1},\ldots,x_{n}$.
\end{defn}

\begin{defn}[\idx{list of variables}]
    Given a function $\lambda((x_{1},\ldots,x_{n}),\ \mathcal{E})$, the ordered tuple $(x_{1},\ldots,x_{n})$ is called the \textbi{list of variables}.
\end{defn}

\begin{defn}[\idx{dummy variable}, \idx{bound variable}]
    Given a function $\lambda((x_{1},\ldots,x_{n}),\ \mathcal{E})$, the variables in the list of variables are called \textbi{dummy variables} or \textbi{bound variables} .

    The symbol used for any bound variable may be changed without changing the value of the expression, provided that we make the same change for each occurrence of the variable and do not make two variables the same that previously were different.
\end{defn}

\begin{exmp}
    The functions $\lambda((x,y),\ y^{2}+x)$, $\lambda((u,v),\ v^{2}+u)$, and $\lambda((y,x),\ x^{2}+y)$ are equivalent.
\end{exmp}

\begin{defn}[\idx{free variable}]
    Given a function $\lambda((x_{1},\ldots,x_{n}),\ \mathcal{E})$, a \textbi{free variable} is a variable which occurs in the expression $\mathcal{E}$ but does not occur in the list of variables. Such an expression may be regarded as defining a function with parameters.
\end{defn}

\begin{defn}[\idx{collision of bound variables}]
    A difficulty which arises in combining functions described by $\lambda$-expressions, or by any other notation involving variables, because different bound variables may be represented by the same symbol.
\end{defn}

\begin{note}
    The $\lambda$-notation is inadequate for naming functions defined recursively. For example, \[\text{sqrt}(a,x,\epsilon) = (\left|x^{2}-a\right| < \epsilon \rightarrow x,\ T \rightarrow \text{sqrt}(a,\frac{1}{2}(x+\frac{a}{x}),\epsilon))\] converts into $\lambda$-notation as \[\text{sqrt} = \lambda((a,x,\epsilon),\ (\left|x^{2}-a\right| < \epsilon \rightarrow x,\ T \rightarrow \text{sqrt}(a,\frac{1}{2}(x+\frac{a}{x}),\epsilon)))\] However, the right-hand side cannot serve as an expression for the function because there would be nothing to indicate that the reference to \texttt{sqrt} within the expression stood for the expression as a whole.
\end{note}

\begin{defn}[\idx{$\text{label}(a,\mathcal{E})$}]
    $\text{label}(a,\mathcal{E})$ denotes the expression $\mathcal{E}$ provided that occurrences of $a$ within $\mathcal{E}$ are to be interpreted as referring to the expression $\mathcal{E}$ as a whole.
\end{defn}

\begin{exmp}
    The \texttt{sqrt} function can be written as
    \[\text{label}(\text{sqrt},\ \lambda((a,x,\epsilon),\ (\left|x^{2}-a\right| < \epsilon \rightarrow x,\ T \rightarrow \text{sqrt}(a,\frac{1}{2}(x+\frac{a}{x}),\epsilon))))\]
\end{exmp}

\subsection{Recursive Functions of Symbolic Expressions}

Objectives:
\begin{enumerate}
    \item Define a class of symbolic expressions in terms of ordered pairs and lists.
    \item Define five elementary functions and predicates, and build from them by composition, conditional expressions, and recursive definitions an extensive class of functions of which we shall give a number of examples.
    \item Show how these functions themselves can be expressed as symbolic expressions.
    \item Define a universal function \texttt{apply} that allows us to compute from the expression for a given function its value for given arguments.
    \item Define some functions with functions as arguments and give some useful examples.
\end{enumerate}

\begin{defn}[\idx{S-expression}]
    \begin{enumerate}
        \item Atomic symbols are S-expressions.
        \item If $e_{1}$ and $e_{2}$ are S-expressions, then so is $(e_{1} \cdot e_{2})$.
    \end{enumerate}
    
    where \textit{atomic symbols} refers to the symbols \texttt{.} \texttt{(} and \texttt{)} as well as digits, strings of letters, and any other symbols that would be used. $S$ stands for `symbolic'.
\end{defn}

\begin{exmp}
    \hfill
    \begin{itemize}
        \item $AB$ [Note: $AB$ is an atomic symbol. If it were a composition of atomic symbols $A$ and $B$, then it would be written as $(A \cdot B)$.]
        \item $(A \cdot B)$
        \item $((AB \cdot C) \cdot D)$
    \end{itemize}
\end{exmp}

\begin{rmrk}
    An arbitrary list \[(m_{1},m_{2},\ldots,m_{n})\] can be represented by the S-expression \[(m_{1} \cdot (m_{2} \cdot (\cdots (m_{n} \cdot NIL) \cdots )))\] where $NIL$ is an atomic symbol used to terminate lists.
\end{rmrk}

\begin{nota}
    \hfill
    \begin{itemize}
        \item $(m)$ stands for $(m \cdot NIL)$
        \item $(m_{1},\cdots,m_{n})$ stands for $(m_{1} \cdot (\cdots (m_{n} \cdot NIL)\cdots))$
        \item $(m_{1},\cdots,m_{n} \cdot x)$ stands for $(m_{1} \cdot (\cdots (m_{n} \cdot x)\cdots))$
        \item $((AB,C),D)$ stands for $((AB \cdot (C \cdot NIL)) \cdot (D \cdot NIL))$
        \item $((A,B),C,D \cdot E)$ stands for $((A \cdot (B \cdot NIL)) \cdot (C \cdot (D \cdot E)))$ 
    \end{itemize}
\end{nota}

\begin{exmp}
    By the above notation, $(m_{1}, m_{2} \cdot x)$ is equivalent to $(m_{1} \cdot (m_{2} \cdot x))$. Let $k = m_{2} \cdot x$. Then $(m_{1}, m_{2} \cdot x) = (m_{1}, k)$ which by notation is equivalent to $(m_{1} \cdot (k \cdot NIL)) = (m_{1} \cdot ((m_{2} \cdot x) \cdot NIL))$. It follows that $(m_{1} \cdot (m_{2} \cdot x)) = (m_{1} \cdot ((m_{2} \cdot x) \cdot NIL))$. So $(m_{2} \cdot x) = ((m_{2} \cdot x) \cdot NIL)$ which agrees with notation. Note then that $((m_{2} \cdot x) \cdot NIL) = (((m_{2} \cdot x) \cdot NIL) \cdot NIL) = ((((m_{2} \cdot x) \cdot NIL) \cdot NIL) \cdot NIL) = \ldots$ 
\end{exmp}

\begin{defn}[\idx{function of S-expressions}, \idx{M-expression}]
    Functions, written in conventional functional notation, taking S-expressions as argument. The expression for a function of S-expressions is called an \textbi{M-expression}; M for `meta'.
\end{defn}

\begin{exmp}
    \hfill
    \begin{itemize}
        \item $car[x]$
        \item $car[cons[(A \cdot B);x]]$
        \item Note the use of square brackets instead of parentheses and the semicolon instead of the comma.
    \end{itemize}
\end{exmp}


\begin{defn}[\idx{atom[X]}]
    atom[X] has the value of T or F according to whether X is an atomic symbol. For example:
    \begin{itemize}
        \item atom[X] = T
        \item atom[(X $\cdot$ A)] = F
    \end{itemize}
\end{defn}

\begin{defn}[\idx{eq[x;y]}]
    Given atomic symbols x,y, eq[x;y] = T iff x and y are equivalent atomic symbols. For example:
    \begin{itemize}
        \item eq[X;X] = T
        \item eq[X;A] = F
        \item eq[X;(X $\cdot$ A)] is undefined since (X $\cdot$ A) is not an atomic symbol.
    \end{itemize}
\end{defn}

\begin{defn}[\idx{car[X]}]
    car[$(e_{1} \cdot e_{2})$] = $e_{1}$. car[X] is undefined if X is an atomic symbol. For example:
    \begin{itemize}
        \item car[(X $\cdot$ A)] = X
        \item car[((X $\cdot$ A) $\cdot$ Y) = (X $\cdot$ A)]
    \end{itemize}
\end{defn}

\begin{defn}[\idx{cdr[X]}]
    cdr[$(e_{1} \cdot e_{2})$] = $e_{2}$. cdr[X] is undefined if X is an atomic symbol. For example:
    \begin{itemize}
        \item cdr[(X $\cdot$ A)] = A
        \item cdr[((X $\cdot$ A) $\cdot$ Y)] = Y
    \end{itemize}
\end{defn}

\begin{defn}[\idx{cons[x;y]}]
    cons[x;y] = (x $\cdot$ y). For example:
    \begin{itemize}
        \item cons[X;A] = (X $\cdot$ A)
        \item cons[(X $\cdot$ A); Y] = ((X $\cdot$ A) $\cdot$ Y)
    \end{itemize}
\end{defn}

\begin{rmrk}
    \hfill
    \begin{itemize}
        \item car[cons[x;y]] = x
        \item cdr[cons[x;y]] = y
        \item cons[car[x];cdr[x]] = x, provided that x is not atomic
        \item cons[car[(X $\cdot$ A)]; cdr[(X $\cdot$ A)]] = cons[X;A] = (X $\cdot$ A)
    \end{itemize}
\end{rmrk}

\begin{defn}[\idx{ff[X]}]
    ff[X] is equivalent to the first atomic symbol of the S-expression X. For example:
    \begin{itemize}
        \item ff[((A $\cdot B$) $\cdot$ C)] = A
        \item ff[x] = [atom[x] $\rightarrow$ x; T $\rightarrow$ ff[car[X]]]
    \end{itemize}
\end{defn}

\begin{defn}[\idx{subst[x;y;z]}]
    subst[x;y;z] is equivalent to the S-expression resulting from substituting the S-expression x for all occurrences of the atomic symbol y in the S-expression z. For example:
    \begin{itemize}
        \item subst[x;y;z] = [atom[z] $\rightarrow$ [eq[z;y] $\rightarrow$ x; T $\rightarrow$ z]; T $\rightarrow$ cons[subst[x;y;car[z]]; subst[x;y;cdr[z]]]]
        \item subst[(X $\cdot$ A); B; ((A $\cdot$ B) $\cdot$ C)] = ((A $\cdot$ (X $\cdot$ A)) $\cdot$ C)
    \end{itemize}
\end{defn}

\begin{defn}[\idx{equal[x;y]}]
    equal[x;y] = T iff x and y are equivalent S-expressions. For example:
    \begin{itemize}
        \item equal[x;y] = [atom[x] $\land$ atom[y] $\land$ eq[x;y]] $\lor$ [$\neg$atom[x] $\land$ $\neg$atom[y] $\land$ equal[car[x]; car[y]] $\land$ equal[cdr[x]; cdr[y]]]
    \end{itemize}
\end{defn}

\begin{rmrk}
    \hfill
    \begin{itemize}
        \item car[$(m_{1}, m_{2}, \ldots, m_{n})$] = car[$(m_{1} \cdot (m_{2} \cdot (\cdots (m_{n} \cdot NIL) \cdots )))$] = $m_{1}$
        \item cdr[$(m_{1}, m_{2}, \ldots, m_{n})$] = cdr[$(m_{1} \cdot (m_{2} \cdot (\cdots (m_{n} \cdot NIL) \cdots )))$] = $(m_{2} \cdot (\cdots (m_{n} \cdot NIL) \cdots ))$ = $(m_{2}, \ldots, m_{n})$
        \item cdr[$(m)$] = cdr[$(m,NIL)$] = $NIL$
        \item cons[$m_{1}$; $(m_{2},\ldots,m_{n})$] = $(m_{1}, m_{2}, \ldots, m_{n})$
        \item cons[$m$; $NIL$] = $(m, NIL)$ = $(m)$
    \end{itemize}
\end{rmrk}

\begin{defn}[\idx{null[x]}]
    null[x] = atom[x] $\land$ eq[x;$NIL$]
\end{defn}

\begin{defn}[\idx{cadr[x]}, \idx{caddr[x]}]
    \begin{itemize}
        \item cadr[x] = car[cdr[x]] - car (a) and cdr (d) makes c(ad)r
        \item caddr[x] = car[cdr[cdr[x]]] - car (a) and two cdr's (dd) makes c(add)r
        \item etc\dots 
    \end{itemize}
\end{defn}

\begin{nota}
    $[e_{1}; e_{2}; \ldots; e_{n}]$ = cons[$e_{1}$; cons[$e_{2}$; \ldots; cons[$e_{n}$; $NIL$]$\ldots$]]

    This function gives the list $(e_{1},\cdots,e_{n})$ as a function of its elements.
\end{nota}

\begin{defn}[\idx{append[x;y]}]
    append[x;y] = [null[x] $\rightarrow$ y; T $\rightarrow$ cons[car[x]; append[cdr[x]; y]]]

    This appends y to the end of the list x. For example:
    \begin{itemize}
        \item append[(A,B); (C,D,E)] = [null[(A,B)] $\rightarrow$ (C,D,E); T $\rightarrow$ cons[car[(A,B)]; append[cdr[(A,B)]; (C,D,E)]]]
        \item cons[car[(A,B)]; append[cdr[(A,B)]; (C,D,E)]]
        \item cons[A; append[B; (C,D,E)]]
        \item append[B; (C,D,E)] = [null[B] $\rightarrow$ (C,D,E); T $\rightarrow$ cons[car[B]; append[cdr[B]; (C,D,E)]]]
        \item cons[car[(B,NIL)]; append[cdr[(B,NIL)]; (C,D,E)]]
        \item cons[B; append[NIL; (C,D,E)]]
        \item append[NIL; (C,D,E)] = (C,D,E)
        \item  append[B; (C,D,E)] = cons[B; append[NIL; (C,D,E)]] = cons[B; (C,D,E)] = (B,C,D,E) 
        \item append[(A,B); (C,D,E)] = cons[A; append[B; (C,D,E)]] = cons[A; (B,C,D,E)] = (A,B,C,D,E)
    \end{itemize}
\end{defn}

\begin{defn}[\idx{among[x;y]}]
    among[x;y] = $\neg$null[y] $\land$ (equal[x; car[y]] $\lor$ among[x; cdr[y]])

    This is true iff x occurs in the list y.
\end{defn}

\begin{defn}[\idx{pair[x;y]}]
    pair[x;y] = [(null[x] $\land$ null[y]) $\rightarrow$ NIL; $\neg$atom[x] $\land$ $\neg$atom[y] $\rightarrow$ cons[list[car[x]; car[y]]; pair[cdr[x]; cdr[y]]]]

    This function gives the list of pairs of corresponding elements of the lists x and y. For example: pair[(A,B,C); (X,(Y,Z),U)] = ((A,X),(B,(Y,Z)),(C,U)).
\end{defn}

\begin{defn}[\idx{assoc[x;y]}]
    assoc[x;y] = [eq[caar[y]; x] $\rightarrow$ cadar[y]; T $\rightarrow$ assoc[x; cdr[y]]]

    If y is a list of the form $((u_{1},v_{1}),\cdots,(u_{n},v_{n}))$ and x is one of the u's, then assoc[x;y] is the corresponding v. For example: assoc[X; ((W,(A,B)),(X,(C,D)),(Y,(E,F)))] = (C,D).
\end{defn}

\begin{defn}[\idx{sub2[x;y]}, \idx{sublis[x;y]}]
    \begin{itemize}
        \item sub2[x;z] = [null[x] $\rightarrow$ z; eq[caar[x]; z] $\rightarrow$ cadar[x]; T $\rightarrow$ sub2[cdr[x]; z]]
        \item sublis[x;y] = [atom[y] $\rightarrow$ sub2[x;y]; T $\rightarrow$ cons[sublis[x; car[y]]; sublis[x; cdr[y]]]]
   \end{itemize}
    
    x is assumed to have the form of a list of pairs ($(u_{1},v_{1}),\cdots,(u_{n},v_{n})$) where the u's are atomic and y may be any S-expression. 
    
    z is assumed to be atomic. sublis[x;y] doesn't use sub2 until y is atomic. Until y is atomic, sublis is recursively applied to the left and right parts of y. Effectively, sublis[x;k] is applied to every atomic symbol k of y such that if k is equivalent to $u_{i}$ in x, then replace k in y with $v_{i}$. Then a new S-expression is constructed with the same structure as y but with the appropriate substitutions having been made. sublis[x;y] returns this new S-expression.
\end{defn}

\begin{exmp}
    sublis[((X, (A, B)), (Y, (B, C))), (A, X $\cdot$ Y)] = (A, (A, B) $\cdot$ (B, C))

    Expand the first argument ((X, (A, B)), (Y, (B, C))) into dot notation:
    \begin{itemize}
        \item (A, B) = (A $\cdot$ (B $\cdot$ NIL))
        \item (B, C) = (B $\cdot$ (C $\cdot$ NIL))
        \item (X, (A, B)) = (X $\cdot$ ((A, B) $\cdot$ NIL)) = (X $\cdot$ ((A $\cdot$ (B $\cdot$ NIL)) $\cdot$ NIL))
        \item (Y, (B, C)) = (Y $\cdot$ ((B, C) $\cdot$ NIL)) = (Y $\cdot$ ((B $\cdot$ (C $\cdot$ NIL)) $\cdot$ NIL))
        \item ((X, (A, B)), (Y, (B, C))) = ((X $\cdot$ ((A $\cdot$ (B $\cdot$ NIL)) $\cdot$ NIL)) $\cdot$ ((Y $\cdot$ ((B $\cdot$ (C $\cdot$ NIL)) $\cdot$ NIL)) $\cdot$ NIL))
    \end{itemize}
    
    The second argument (A, X $\cdot$ Y) expands into dot notation as:
    \begin{itemize}
        \item (A, X $\cdot$ Y) = (A $\cdot$ ((X $\cdot$ Y) $\cdot$ NIL))
    \end{itemize}

    

    

\end{exmp}